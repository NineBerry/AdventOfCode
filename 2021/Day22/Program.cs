// #define Sample

using System.Text.RegularExpressions;

{
#if Sample
    string fileName = @"D:\Dropbox\Work\AdventOfCode\2021\Day22\Sample.txt";
#else
    string fileName = @"D:\Dropbox\Work\AdventOfCode\2021\Day22\Full.txt";
#endif

    Cuboid[] commands = File.ReadAllLines(fileName).Select(Cuboid.CreateFromLine).ToArray();
    Cuboid[] cuboidsOn = ApplyCommands(commands);

    Console.WriteLine("Part 1: " + Part1(cuboidsOn));
    Console.WriteLine("Part 2: " + Part2(cuboidsOn));
    Console.ReadLine();
}

long Part1(Cuboid[] cuboidsOn)
{
    Cuboid interestArea = new Cuboid(-50, -50, -50, 101, 101, 101);
    Cuboid[] cuboidsOnInsideArea = RestrictToArea(cuboidsOn, interestArea);
    return CountVolume(cuboidsOnInsideArea);
}

long Part2(Cuboid[] cuboidsOn)
{
    return CountVolume(cuboidsOn);
}

Cuboid[] ApplyCommands(Cuboid[] commands)
{
    List<Cuboid> sourceList = [];
    List<Cuboid> resultList = [];

    foreach (Cuboid command in commands)
    {
        sourceList = resultList;
        resultList = [];


        foreach (var sourceCuboid in sourceList)
        {
            var intersectionResult = CuboidSplitter.SplitCuboids(sourceCuboid, command);
            resultList.AddRange(intersectionResult.PartsOfA);
        }

        if (command.TurnOn)
        {
            resultList.Add(command);
        }

    }
    return resultList.ToArray();
}

long CountVolume(Cuboid[] cuboids)
{
    return cuboids.Sum(c => c.GetVolume());
}

Cuboid[] RestrictToArea(Cuboid[] cuboidsOn, Cuboid interestArea)
{
    List<Cuboid> result = [];
    
    foreach(var input in cuboidsOn)
    {
        var intersectionResult = CuboidSplitter.SplitCuboids(input, interestArea);
        result.AddRange(intersectionResult.Intersection);
    }
    
    return result.ToArray();
}


// Cuboid splitting code based on code generated by ChatGPT 3.5

public class Cuboid
{
    public bool TurnOn {  get; set; }   

    public long X { get; set; }
    public long Y { get; set; }
    public long Z { get; set; }
    public long Width { get; set; }
    public long Height { get; set; }
    public long Depth { get; set; }

    public Cuboid(long x, long y, long z, long width, long height, long depth)
    {
        X = x;
        Y = y;
        Z = z;
        Width = width;
        Height = height;
        Depth = depth;
    }

    // Method to check if two cuboids intersect
    public bool Intersects(Cuboid other)
    {
        return !(X + Width <= other.X || other.X + other.Width <= X ||
                 Y + Height <= other.Y || other.Y + other.Height <= Y ||
                 Z + Depth <= other.Z || other.Z + other.Depth <= Z);
    }

    public long GetVolume()
    {
        return Width * Height * Depth;
    }

    public static Cuboid CreateFromLine(string line)
    {
        Match match = Regex.Match(line, "x=(-?\\d+)\\.\\.(-?\\d+),y=(-?\\d+)\\.\\.(-?\\d+),z=(-?\\d+)\\.\\.(-?\\d+)");

        long x1 = long.Parse(match.Groups[1].Value);
        long x2 = long.Parse(match.Groups[2].Value);
        long y1 = long.Parse(match.Groups[3].Value);
        long y2 = long.Parse(match.Groups[4].Value);
        long z1 = long.Parse(match.Groups[5].Value);
        long z2 = long.Parse(match.Groups[6].Value);
        bool turnOn = line[1] == 'n';

        return new Cuboid(x1, y1, z1, x2 - x1 + 1, y2 - y1 + 1, z2 - z1 + 1) { TurnOn = turnOn };
    }
}

public static class CuboidSplitter
{
    public static (List<Cuboid> PartsOfA, List<Cuboid> PartsOfB, List<Cuboid> Intersection) SplitCuboids(Cuboid A, Cuboid B)
    {
        var partsOfA = new List<Cuboid>();
        var partsOfB = new List<Cuboid>();
        var intersection = new List<Cuboid>();

        // Check if A and B intersect
        if (!A.Intersects(B))
        {
            // No intersection
            partsOfA.Add(A);
            partsOfB.Add(B);
            return (partsOfA, partsOfB, intersection);
        }

        // Calculate the intersection cuboid
        long interX = Math.Max(A.X, B.X);
        long interY = Math.Max(A.Y, B.Y);
        long interZ = Math.Max(A.Z, B.Z);

        long interWidth = Math.Min(A.X + A.Width, B.X + B.Width) - interX;
        long interHeight = Math.Min(A.Y + A.Height, B.Y + B.Height) - interY;
        long interDepth = Math.Min(A.Z + A.Depth, B.Z + B.Depth) - interZ;

        var intersectCuboid = new Cuboid(interX, interY, interZ, interWidth, interHeight, interDepth);
        intersection.Add(intersectCuboid);

        // Add remaining parts of A not in the intersection
        AddRemainingParts(partsOfA, A, intersectCuboid);

        // Add remaining parts of B not in the intersection
        AddRemainingParts(partsOfB, B, intersectCuboid);

        return (partsOfA, partsOfB, intersection);
    }

    private static void AddRemainingParts(List<Cuboid> parts, Cuboid original, Cuboid intersect)
    {
        // Create the remaining parts of the original cuboid not covered by the intersection

        // Define the coordinates of the intersecting cuboid
        long interXEnd = intersect.X + intersect.Width;
        long interYEnd = intersect.Y + intersect.Height;
        long interZEnd = intersect.Z + intersect.Depth;

        // 1. Left of the intersection
        if (original.X < intersect.X)
        {
            parts.Add(new Cuboid(original.X, original.Y, original.Z, intersect.X - original.X, original.Height, original.Depth));
        }

        // 2. Right of the intersection
        if (original.X + original.Width > interXEnd)
        {
            parts.Add(new Cuboid(interXEnd, original.Y, original.Z, (original.X + original.Width) - interXEnd, original.Height, original.Depth));
        }

        // 3. Below the intersection
        if (original.Y < intersect.Y)
        {
            parts.Add(new Cuboid(Math.Max(original.X, intersect.X), original.Y, original.Z, Math.Min(original.Width, intersect.Width), intersect.Y - original.Y, original.Depth));
        }

        // 4. Above the intersection
        if (original.Y + original.Height > interYEnd)
        {
            parts.Add(new Cuboid(Math.Max(original.X, intersect.X), interYEnd, original.Z, Math.Min(original.Width, intersect.Width), (original.Y + original.Height) - interYEnd, original.Depth));
        }

        // 5. In front of the intersection
        if (original.Z < intersect.Z)
        {
            parts.Add(new Cuboid(Math.Max(original.X, intersect.X), Math.Max(original.Y, intersect.Y), original.Z, Math.Min(original.Width, intersect.Width), Math.Min(original.Height, intersect.Height), intersect.Z - original.Z));
        }

        // 6. Behind the intersection
        if (original.Z + original.Depth > interZEnd)
        {
            parts.Add(new Cuboid(Math.Max(original.X, intersect.X), Math.Max(original.Y, intersect.Y), interZEnd, Math.Min(original.Width, intersect.Width), Math.Min(original.Height, intersect.Height), (original.Z + original.Depth) - interZEnd));
        }
    }
}